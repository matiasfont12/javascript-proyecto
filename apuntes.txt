
Control de flujo: 

Condicionales en JS: En las condicionales nosotros vamos a dar por definicion circunstancias que se cumplan en distintas condiciones especificas

Variables Boolean: El tipo de dato booleano es afirmar si lo que estamos trabajando es verdadero o falso

Se aceptan valores True o False, se los podemos dar directamente a nuestras variables, asi como guardabamos strings o numeros

Estructura = La estructura mas utilizada en los condicionales es la palabra reservada if, que da la condicion que cuando algo sea afirmativo, que se cumpla

En javascript, el if se acompaña con (), en donde dentro de este parentesis vamos a especificar nuestra variable junto a la condicion que queremos que cumpla, y las instrucciones que especificamos que deben ejecutarse deben ser en llaves

if (condicion) {
    instrucciones
}

Ej) if (edad > 18) {
    alert("Sos mayor de edad")
}

Hay muchas condiciones que podemos añadir a nuestra variable, como < o >, <= o >=, == o != 

Else: La palabra reservada else, sirve para acompañar al if, esto sirve para plantear dos posibles opciones a la condicion que trabajemos, por ejemplo, trabajar algo afirmativo en el if, y si no es afirmativo trabajarlo en el else

Ej) 

if (edad >= 18) {
    alert("Sos mayor de edad")
}
else {
    alert("No sos mayor de edad")
}

else if: El else if (funciona como el elif en python) sirve para trabajar condiciones que no todo el tiempo son blanco o negro, ya que este funciona para proporcionar una tercera opcion 

Es util usar el else if antes de usar un else definitivo. asi con el else if dar bastantes opciones, y dar una opcion definiva del programa con el else 

Esto se da especificamente en javascrit por una cuestion de orden, pero en python usabamos el elif como ultima carta

Ej) if (edad >= 18) {
    alert("Sos mayor de edad");
}
else if (edad == 4) {
    alert("Sos un bebe");
}
else {
    alert("No sos mayor de edad");
}

Si nosotros usamos el else if como ultima afirmacion, lo que nos da esto es un error en el orden de las cosas,

Operadores en JS: == Es igual , === Es estrictamente igual, != Es distinto, !== Es estrictamente distinto, && (AND), sirve para dar dos condiciones 

Para usar && en un if, necesitamos que ambas condiciones que aplicamos sean verdaderas 

Tambien tenemos el operador or, en js lo usamos ||, en donde esperamos que alguna de las afirmaciones sea verdadera 

En caso de combinar operadores, tenemos que tener cuidado en el orden que usamos, ya que podemos ir combinando tipos de operadores, como en la misma afirmacion usar &&, y ||, al ser asi debemos respetar los parentesis, y respetar las jerarquias y reglas de cada operador

Ciclos e iteraciones: Los ciclos o tambien conocidos como bucles, sirven para generar una acción de una manera repetida, de esta manera realizamos acciones de manera automatica y nos evitamos definir muchas veces el mismo codigo 

Tipos de ciclos: Ciclos por conteo como el for y ciclos condicionales como el while y do while

La diferencia entre estos tipos de ciclos, es que los ciclos por conteo define un numero especifico para una condicion que asignemos, y los ciclos condicionales repiten la accion sin un numero especifico de repeticiones de manera automatica

Estructura for: La estructura for recibe 3 valores distintos en distintos tiempos 

for(desde; hasta; actualización) {

}

El primer valor es el valor inicial en donde empieza la iteracion, el primer valor es nuestra variable let i = desde 0

for(let i = 0)

El orden en el cual se ejecuta el ciclo, es desde el inicio, hasta la actualizacion hasta que el segundo parametro se deja de cumplir

Ej) for(let i = 0; i >= 5; i + 1 ) {
    console.log(i)
}

Como vemos, el ciclo se repite desde el la primer instrucción y la tercera instrucción que ejecuta la segunda, y asi hasta que la segunda instrucción no se pueda ejecutar mas

Tambien podemos tener un for que adentro tenga otro for, pero esto debe ser usandolo con otra variable, no con la misma

Un tip para hacer un poco mas corta la sintaxis, es en el parametro de actualizacion, incluir i += "numero de ejemplo" 

Es una abreviatura que podemos usar, otra que tambien podemos usar es i++ o i--, Aunque esto solamente indica que le estoy sumando o restando 1 solo 

Un ejemplo practico, es hacer una turnera con este sistema 

Ej) 

for(let i = 1 ; i < 3 ; i++){

    if(i == 2){
        alert("Apurate, este es el ultimo turno")
    }
    let nombreIngresado = prompt("Ingrese su nombre:")
    alert("Bienvenido " + nombreIngresado + "." + "\nSu turno es el N:" + i)
}
alert("Nos quedamos sin turnos por hoy")

Recordar tambien que podemos utilizar variables definidas en nuestro ciclo for, pero lo mas normal es usarlas en el segundo orden

Break & Continue: Estas dos sentencias, sirven para especificar una acción especifica, el continue sirve saltear la iteraccion, el break sirve para cortar completamente el ciclo 

Aunque, para utilizar estas sentencias debemos tener en cuenta un orden logico, ya que no siempre tiene sentido usar estas sentencias en una cadena

While: Cuando usamos un while, no definimos un numero exacto de repeticiones, por eso es que en algun momento debemos cortar la repeticion, si no la cortamos vamos a generar un bucle infinito 

Para usar el while, como parametro tenemos que dar un parametro verdadero 

while()

Para esto usamos el do while

Do while: El do while garantiza que por lo menos la repeticion se genera una o dos veces, y luego se corte si es falsa

let repetir = false; 
do {
    console.log("solo una vez");
    }while(repetir)
}

Los do while, tambien los podemos iniciar con un for, en ciertos momentos es mas eficiente hacer alguno u otro

Switch: El switch me va a permitir manejar varias condiciones sobre una misma variable, esto no es un bucle, si no una sentencia como ya habiamos visto

El switch es una estructura un poco mas ordenada, en la cual nos da la facilidad de poner multiples condiciones sobre la misma variable

Algo importante, es a los switch, cuando termina la ejecucion que queremos realizar, incluirles un break final

Case & Default: El case es lo que va a reemplazar a cada una de las condiciones if, y el default es para reemplazar lo que seria un else, ya que el default se usa para cuando no cumple ninguna de esas condiciones 

Todo esto lo debemos usar cuando incluimos un switch

Un caso usando switch, recordar que para que el switch funcione, debemos incluirle un True, para que el codigo pueda funcionar
let precio = parseInt(prompt("Ingrese el precio:"))

switch(true){
    case precio < 20:
        alert("El precio es menor que 20");
        break;
    case precio < 50:
        alert("El precio es menor que 50");
        break;
    case precio < 100:
        alert("El precio es menor que 100");
        break;
    case precio > 100:
        alert("El precio es mayor que 100");
        break;
    default:
        console.log(precio)
        alert("No ingresaste un precio en numeros");
        break;
}


Tenemos que evaluar bien cuando nos conviene mas usar un if o un switch, cuando el codigo algo simple sin muchas comparaciones, conviene usar if, pero cuando estamos haciendo algo un poco mas extenso, conviene usar el switch

Switch es para usarse en ciertas ocasiones puntuales, pero normalmente vamos a usar if
Programacion con funciones: 

Funciones: Una funcion se denomina como un conjunto de instrucciones que sirven para realizar una tarea especifica, lo importante de esto, es que esto nos permite re utilizar estas herramientas

Dentro de las funciones, utilizamos la metodologia dry (Dont repeat yourself ), 
que nos sirve para repetir la menor cantidad de codigo posible, ademas con ellas podemos solucionar un problema muy complejo, tratandolo en porciones mas simples, en ellas se focalizan tareas principales para el programas, la funcion aporta entendimiento y utilidad al codigo y en el vienen la facilidad y rapidez para hacer modificaciones en el codigo 

Declaracion de funciones: Las funciones se declaran con la palabra reservada function(), a esta palabra tenemos que acompañarla con un nombre, tener en cuenta que tantos funciones como palabras, las debemos nombrar en CamelCase , y finalmente las instrucciones dentro de la funcion deben estar entre las llaves

ej) function saludar() {
    console.log("Hola estudiantes");
}

pero aca solamente estamos declarando esta funcion, nunca la estamos ejecutando, para ejecutar esta funcion debemos hacerle un llamado

Para llamar la funcion tenemos que escribir el nombre de la funcion junto a () vacios,

ej) saludar();

y aqui es donde se va a ejecutar esta funcion

nuestro ejemplo de funcion quedaria algo asi: 


function saludar(){
    console.log("Bienvenidos a todos")
}

saludar();

en donde en la consola se mostraria el mensaje que nosotros escribimos

a esta funcion saludar, la podemos repetir todas las veces que nosotros desearamos

Nosotros por ahora, utilizamos las funciones sin ningun parametro dentro del parentesis, 

Pero la utilidad de añadir parametros, es que a nuestra funcion le añadimos informacion de afuera y a este argumento lo utilizamos dentro de la funcion 

Lo que tenemos que tener en cuenta es manejar la legibilidad dentro de los parametros que pasamos, para que pueda entenderse la funcionalidad de nuestra funcion


Ej) function suma (num1, num2){
    let numero = num1 + num2;
    console.log(numero)
}

suma(2, 6)
suma(8, 24)

y a medida que le pasamos numeros, va a ir realizando nuestra suma 

Return: La palabra reservada return, sirve para devolver algun valor, y esto es lo correcto de trabajar, ya que si no solamente lo que usamos en la funcion queda en la funcion, con el return la podemos usar tambien fuera de la funcion

ej) 

function suma(num1, num2){
    return num1 + num2
}

function mensaje(resultado){
    console.log(resultado)
}

let numeroA = parseInt(prompt("Ingrese el primer numero"))
let numeroB = parseInt(prompt("Ingrese el segundo numero"))

let numeroTotal = suma(numeroA, numeroB)
mensaje(numeroTotal)

Lo mejor es llamar a la funcion luego de declararla

Scopes: El scope es el ambito o lugar en donde vamos a declarar una variable, hablamos del contexto al que pertenece la misma dentro de un algoritmo restringiendo el uso y su alcance, 

Tenemos dos tipos de scopes, scopes globales y locales

Como definir cada una?

Si la variable esta declarada de manera independiente, declarada fuera de cualquier bloque, estamos hablando de una variable global 

En cambio, si tenemos una variable que esta definida dentro de un bloque, estamos hablandod de una variable local, en donde solamente podemos usarla dentro de ese contexto

Siempre tener en cuenta que un scope global no puede usar un scope local, ya que esto daria un error

Lo ideal, es tener la menor cantidad de variables globales posibles, ya que consumen mucho espacio de almacenamiento, en cambio las variables locales no ocupan este espacio en la memoria ya que cuando se ejecute la funcion esa variable se va a destruir hasta nueva ejecucion, evitando usar espacio en la memoria

Funciones anonimas y funciones flecha:

Hasta ahora vimos el metodo normal de declarar una funcion, ahora, hay nuevas formas de declarar una funcion de una manera mas avanzada, y esto se añadio en las nuevas actualizaciones es6 en js

Aunque, esto no sustituye el uso de las funciones clasicas como ya habiamos visto, todo esto sirve para situaciones en especiales en donde lo requiera

Funciones anonimas: Una funcion anonima es una funcion que se define sin nombre, si no que se usa asignandola a una constante con nombre, y se utiliza para ser usada como un parametro o asignada a una variable

Lo util de esta funcion, es usarla cuando necesitamos usar una funcion que no vamos a reutilizar, si no usarla para algo en particular que se ejecuta en ese momento 

ej) const suma = function (a, b) {return a + b}
 
console.log(suma(15,20))

Funciones flecha: Es como la funcion anonima pero un poco mas simplificada,

ej) const = suma (a, b) => {return a + b}

console.log(suma(20, 5)) 

La diferencia entre estas dos funciones, es meramente de sintaxis, y normalmente lo que mas se usa son las funciones clasicas o las funciones flecha

En particular, las funciones flechas se utilizan mucho para trabajar React

Objetos: 

Un objeto en javascript es una esctructura que se usa para agrupar distintos valores dentro de una misma cosa, como una coleccion de datos que estan relacionados entre si, en forma de pares key/valor

Como declaramos un objeto?

Los objetos se asignan a traves de llaves y en un tipo de variable constante, y en estas llaves vamos a tener nuestros pares key/valor 

ej) 

const persona = {
    nombre: "Homero", 
    edad: 39,
    calle: "Ameghino
}

y toda esta informacion se va a encontrar almacenada en una sola variable, que seria la variable constante llamada persona

a cada key que nosotros creamos, se le llama propiedad, y se dice que cada key es una propiedad de en este caso persona

Para acceder desde el exterior a estas propiedades, tenemos dos formas distintas

La primer forma es usar la notacion (.), en donde escribimos el nombre del objeto acompañado de un . y la propiedad

ej) console.log(persona.nombre)

Y la otra forma para obtener un valor dentro de un objeto, es usar la notacion en corchetes ([])

ej)

console.log(persona["nombre"])

aca la propiedad va entre comillas en los parentesis 

lo mas sencillo es usar la notacion de puntos, pero en momentos va a ser mas util usar la propiedad de corchetes, ya que si el objeto no existiera, este tiene la posibilidad de crearlo, y en caso contrario usando la notacion, si no encuentra el objeto nos devuelve un error 

No solamente nosotros podemos acceder a estos valores para su uso, si no que tambien con estas notaciones podemos asignarles nuevos valores a estas variables

ej) 

persona["nombre"] = "Marge"
persona.edad = 36

Objetos constructores: 

el constructor sirve para crear objetos que van a tener las mismas propiedades

esto se crea usando funciones, importante usar el constructor usarlo en pascalCase, es decir que siempre la funcion constructora debe ir con mayuscula

ej) function Persona(nombre, edad, calle){
    this.nombre = nombre;
    this.edad = edad;
    this.calle = calle;
}

const persona1 = new Persona("Homero", 39, "Ameghino 1556")];
const persona2 = new Persona ("Marge", 36, "Ameghino 1556");

y para ejecutar esta funcion constructura, debemos usar una palabra extra

Entonces, el constructor crea una funcion, en donde va trabajando las caracteristicas que van a tener en comun los objetos que va a crear, y luego con la palabra reservada this, acompañada del parametro hace mencion a lo que va a crear.

Y luego la ejecucion del constructor, se hace creando otra variable, pero incluyendole el constructor con los atributos que configuramos para que cree

El constructor en javascript, es lo que se usa como models en python

Metodos y operaciones:

Un metodo es una funcion, pero que esta definida dentro del objeto y solamente la vamos a poder ejecutar en ese objeto

Hay metodos especiales que se encargan de ejecutar una accion determinada

ej)

let cadena = "HOLA CODER";

console.log(cadena.lenght);
console.log(cadena.toLowerCase)
console.log(cadena.toUpperCase)

Estos son distintos metodos que se aplican a la variable que nosotros creamos, e interactuan haciendo una accion a esta variable

Por ejemplo, el primer metodo devuelve el numero de caracteres que tiene nuestro string

Hay metodos que llevan predeterminadamente parentesis, y otras no, esto se da porque hay metodos que son funciones y otras son propiedades

Tambien hay metodos que nosotros podemos usar de manera personalizada, esto lo podemos mezclar con funciones anonimas, y ejecutariamos funciones que creamos con metodos personalizados

ej)

function Producto(nombre, precio, stock){
    this.nombre = nombre
    this.precio = precio 
    this.stock = stock
    this.sumarIva = function(precio){
        return precio * 1.21
    }
    this.sumarStock = function (cantidad) {this.stock += cantidad}
}

const productoB = new Producto("Silla", 3000, 20)

productoB.sumarIva()
productoD.sumarStock(28)


aca estamos creando nuestro propio metodo, tratandolo como una funcion anonima dentro de un constructor, y esto es algo util de hacer, es que creamos una funcionalidad propia

esto se ejecuta como una funcion, aparte, ya que no tenemos que hacer mencion al constructor

Operador in y for in: Estos operadores sirven para acceder a la propiedad de manera interna 

Clases:

Nosotros vimos como hacer una funcion constructora, pero existen otras formas de construir, y esto lo podemos realizar con el uso de clases, que es similar pero agregando cosas extras ya que permite definir otro tipo de datos

Las clases se añadieron en las ultimas actualizaciones de javascript, y el sentido de esto es que es una forma de construir parecida a otros lenguajes, aunque podemos usar cualquiera de las dos

ej) class Persona{
    constructor(nombre, edad, calle){
        this.nombre = nombre;
        this.edad = edad;
        this.calle = calle;
    }
    hablar(){
        console.log("Hola soy " + this.nombre)
    }
}

const persona1 = new Persona("Homero", 39, "Ameghino 1556")

Dentro de estas clases, se llama a la palabra reservada llamada constructor, que funciona como una funcion anonima, y si nosotros queremos añadir metodos, tenemos que hacerlos por fuera del constructor, ya que en el constructor solo ponemos propiedades, y fuera del constructor incluimos los metodos

Usar clases, o funciones constructoras es muy similar, queda en cada uno ver que usamos para cada cosa

Arrays:

Que es un array? Un Array es otro tipo de dato, como lo son los numeros, los strings y los booleans, que nos sirve para almacenar otros valores pero en forma de lista

Estos elementos tienen un indice, en donde su orden de lista, va desde el 0 hasta el ultimo indice

Declaracion del Array:

let lista = ["Matias", "Font", 1556, True] 

y dentro de este corchete, vamos a escribir los valores que queremos almacenar dentro de esta lista, tambien podemos crear arrays con const, 

Les importante respetar este indice, ya que representan a la posicion del elemento, y esto lo tenemos que tener en cuenta para acceder a ellos

Ejemplo)

let lista = [5, "Coder", 80, true, "House"] 

console.log(lista[3])

Para poder acceder a estos valores por separado vamos a indicar el indice del valor que nosotros queremos, entre corchetes

Si nosotros indicamos el indice del array negativo, 

Los arrays en javascript son iterables, y eso significa que podemos utilizar palabras reservadas para interactuar con ellos

Ej)

const numeros = [1,2,3,4,5]
for(let i = 0; i < 5; i++){
    console.log(numeros[i])
}

de esta manera, va recorriendo todo el array mostrando cada valor en consola 

Junto con los arrays, podemos aplicar metodos para trabajar con ellos

Como por ejemplo, el metodo length (GTH no confundirse), que es una propiedad del metodo array

Que gracias a este metodo, podemos extraer elementos del array, tambien podemos eliminar elementos con pop, y tambien lo va a devolver

Splice: El metodo splice nos va a permitir ir al detalle de donde y cuanto queremos sacar

lista.splice(2,2)

Tenemos que indicar 2 parametros, el primero sera el indice en el cual arrancaremos a sacar elementos y el segundo sera de cuantos elementos queremos sacar

podemos hacer varios splices, uno detras de otro

Concat: El metodo concat sirve para sumar dos arrays

Slice: El metodo Slice sirve para devolver una copia de una parte del slice

Indexof: Sirve para obtener el indice de un elemento de un array, si no encuentra el indice de este elemento, arroja un valor negativo -1

Include: Se encarga de verificar si un valor existe dentro de un array, devolviendo un valor boolean true or false

Reverse: Sirve para invertir el valor del array

El metodo reverse, debe usarse con cuidado ya que es un metodo destructivo, igual que el pop o el push,

Esto significa que si tenemos un array con cierta informacion, la va a modificar por completo

Arrays de objetos:

Tambien como almacenabamos tipos de datos, tambien podemos almacenar objetos con el metodo push o constructor

ej) const objeto1 = {id: 1, producto: "Arroz"};

const array = {objeto1, {id: 2, producto: "Fideo"}};


Higher Order Functions:

Las funciones de orden superior, son aquellas que recibe una funcion por parametro, o que retornan una funcion distinta

Recibir funciones por parametro:

ej) function porCadaUno(arr, fn){
    for (const el of arr){
        fn(el)
    }
}

Dentro de la funcion inicial, recibe como parametro un array o una funcion

Esta funcion recibe un array por primer parametro y una funcion en el segundo, recorre el array y por cada elemento hace un llamado a la funcion recorrida

importante saber que lo que nosotros llamamos el, es una referencia a elemento, aunque nosotros la podriamos llamar de distinta manera ya que solamente es una referencia al nombre del indice

La utilidad de esto, es poder crear nuestros propios metodos sin tener que recurrir a alguno que quizas no cumpla la accion que queremos definir en la informacion

Cuando nosotros declaramos la hof, hasta que no la ejecutamos no tiene utilidad ni validacion en si, ya que en ese momento solamente nuestra hof son referencias

Otra forma ordenada y sintactica de darle un uso a este tipo de funcion, es hacerlo atraves de la funcion flecha

un ejemplo practico:


// function asignarOperacion(op){
//     if(op == "sumar"){
//         return (a,b) => a + b
//     }
//     else if (op == "restar"){
//         return (a,b) => a - b
//     }
// }

// let suma = asignarOperacion("sumar")
// let resta = asignarOperacion("restar")

// console.log(suma(4,6))
// console.log(resta(5,3))

otro ejemplo)

function porCadaUno(arr, fn){
    for (const el of arr){
        fn(el)
    }
}

const numeros = [1,2,3,4,5,6]

let total = 0

function acumular(num){
    total += num
}

porCadaUno(numeros, (num) => {total += num})

y asi es como estariamos utilizando dos funciones a traves de una, la desventaja es que si esto lo tenemos que usar en otro lado lo tenemos que volver a escribir

Metodos de busqueda de informacion:

Hay 7 metodos de busqueda de informacion de hof:

1) forEach(): Este metodo itera sobre el array y por cada elemento ejecuta la funcion que enviemos por parametro, la cual recibe a su vez el elemento del array que se esta recorriendo

ej) const numeros = [1,2,3,4,6]

numeros.forEach((num))=> {
    console.log(num)
}

Este metodo, nos evita hacer el recorrido anterior con las funciones, y lo hace mucho mas simple

2) find(): El metodo find (o buscar) recibe una funcion de comparacion por parametro, capturando al elemento que esta recorriendo y retornando true or false segun la comparacion. Este metodo retorna el primer elemento que cumpla la condicion

Importante esto, solamente devuelve un valor boolean, no devuelve el tipo de dato de ese objeto

ej)

const cursos = [
    {nombre: "javascript", precio: 15000}
    {nombre: "ReactJS", precio: 22000}
]

const resultado = cursos.find((element)) => element.nombre === "ReactJS"
const resultado2 = cursos.find((element)) => element.nombre === "DESARROLLO WEB"

y en caso de no encontrar ningun valor, devuelve un valor undefined

3) filter(): El filter se dice que es la version pro del find(), ya que tambien retorna una funcion que compara a cada uno de los elementos que definamos en la funcion, solamente que el filter se encarga de retornar los resultados de esta comparacion dentro de un array. 

Lo importante es esto, el filter no devuelve un tipo de valor boolean, si no que devuelve un array con la informacion solicitada

ej)

const cursos = [
    {nombre: "javascript", precio: 15000}
    {nombre: "ReactJS", precio: 22000}
]

const resultado = cursos.filter((element)) => element.nombre.includes(("JS"))
const resultado2= cursos.filter((element)) => element.precio < 14000)

console.log(resultado)
console.log(resultado2)


Si no encuentra ningun elemento, lo que va a devolver es una array vacio

El filter tambien sirve para utilizar filtros

4) Map(): El metodo map es muy utilizado, ya que crea un nuevo array con los metodos del array original pero transformado 

La diferencia con el filter, es que este no necesita una condicion para que se devuelvan los elementos, si no que devuelve un nuevo array especificamente lo que necesitamos de una forma mucho mas simple

6) reduce()

7) sort(): El metodo sort es parecido al metodo reverse, ya que tambien es destructivo y tambien da vuelta el array.

Pero tambien puede ordenarlo de forma ascendente o descendente, recibiendo dos parametros y comparando entre si

ej)

const numeros = [40, 1, 5, 200];

numeros.sort((a, b)) => a - b)
numeros.sort((a,b)) => b - a)

y lo que va a realizar es un orden de menor a mayor, o de mayor a menor 

DOM (Modelo de objetos del documento):

El dom es sensillamente una estructura de objetos, en donde se trabaja el interpretado del navegador junto a nuestra pagina html. (Es la estructura que va a tener el navegador)

Esto nos sirve porque al dom que genera el navegador vamos a poder modificarlo a traves de javascript de forma dinamica

Como funciona el dom?: El dom funciona a traves de distintos nodos, nodos padres y nodos hijos, esto esta muy relacionado con la anidacion de etiquetas, en donde la etiqueta que genera la anidacion, se dice que es el nodo padre, y las que reciben esta anidacion son los nodos hijos

Entonces, todas las etiquetas que tengamos en html, se transformaran en nodos elementos

Y lo que esta dentro de las etiquetas, tambien se traducira como nodos, pero en diferencia, estos seran nodos text o textos

De esta manera es que el navegador comprende lo que nosotros escribimos en html

Tipos de nodos:  Document, Element, Attr, Text, Comment. Aunque nosotros vamos a usar los principales (document, element, text)

Acceso al dom: 

Existen distintos metodos asociados para acceder a los elementos del dom, y poder hacer un junte entre lo que trabajamos en html y lo que hicimos en js:

Los mas comunes son:

getElementByld()
getElementsByClassName()
getElementsByTagName()

GetElementById(): Hace referencia a los nodos que se pasan por un id 

ej)
let titulo = document.getElementById("titulo")
console.log(paises)

lo mismo podemos hacer si tratasemos de clases

ej) 

let paises = document.getElementsByClassName("paises")
console.log(paises[0])

y el ultimo es hacer el llamado del dom por la etiqueta html especifica, aunque no es muy recomendado usar esto

ej)

let paisestag = document.getElementsByTagName("li")

Modificar nodos: 

InnerText:

La propiedad innerText de un nodo nos permite modificar el texto del nodo, es decir poder acceder o modificar el texto que se encuentra escrito 

ej)

titulo.innertext = "estoy modificando el texto"

y de esta forma cambiaria automaticamente desde js nuestro titulo que teniamos en html

lo util de esto, es por ejemplo trabajar filtros especificos que el usuario selecciona, y nosotros esto en el html no lo podemos trabajar, para hacer este dinamismo lo tenemos que trabajar desde javascript

por ejemplo) el usuario desea buscar productos que cumplen con un filtro especifico, nosotros vamos a tener que cumplir esta necesidad de hacer un recorte para que se muestre solo las cosas que funcionen con ese filtro, esto lo podriamos hacer gracias a javascript, ya que en html nuestros elementos estarian todos juntos 

InnerHtml: 

Esta propiedad, permite definir el codigo html interno, ya que podemos modificar el codigo html hijo que existe en el nodo, asi podriamos modificar etiquetas, o tambien agregarlas 

ej)

let contenedor = document.getElementById("contenedor")
contenedor.innerHTML = "<h4>Bienvenido</h4>

Y asi es como cambiamos la etiqueta, junto a lo que decia 

ClassName:

La propiedad className, sirve para acceder a las clases que nosotros tenemos en css, y en ellas tambien podemos hacerle modificaciones o agregarle cosas

Agregar o quitar nodos:

Si bien vimos que podemos agregar o quitar nodos, aunque no necesariamente lo debemos de hacer de esta forma, ya que estamos haciendo una modificacion en lo que tenemos originalmente 

lo podemos hacer con el metodo document.createElement()

este elemento permite añadir cualquier etiqueta html que nosotros quisieramos, pero lo mas correcto es trabajar esto con un metodo append()

ej)

let nuevoPais = document.createElement("li")
nuevoPais.innertext = "mx"
nuevoPais.className = "paises"
let lista = document.getElementById("lista")
lista.append(nuevoPais)

asi es como creamos una clase y una etiqueta especifica html, y como podemos hacer esto, tambien podemos eliminar elementos

para eliminar elementos vamos a utilizar el metodo .remove() siempre haciendo referencia al elemento que queremos utilizar

ej)

let subtitulo = document.getElementByld("subtitulo")
subtitulo.remove()

aunque esto hacerlo asi es poco dinamico, lo mejor para tratar esto es usar botones, o un tacho de basura y no forzar los elementos asi

Literals:

` esto es un backtick, que permite ahorranros la iteracion entre sumar strings y variables, en vez de hacer esto vamos a agregarlas a traves de ${variable}

esto es util si es que tenemos que hacer una sumatoria importante de variables y strings, para acortar un poco esto

Eventos: Los eventos en javascript es tomar el control sobre las acciones que puede realizar el usuario en nuestra pagina, para hacer esto podemos declarar una funcion, teniendo en cuenta el compartamiento que nosotros necesitemos, y a esta funcion asignarle un evento determinado

esto recibe el nombre de un events handlers o manejadores de eventos, la respuesta a estos eventos se le llaman events listener

(revistar nuevamente la clase a ver si no me perdi nada)

como definir eventos en js?

1) el metodo addEventListener(), en donde en sus parametros le tenemos que pasar un evento

por ejemplo, un evento bastante normal, es el evento llamado "click"

esto se usa de la siguiente manera:

ej)

let boton = document.getElementById("boton1")

boton.addEventListener("click", clickHandler)

function clickHandler(){
    console.log("click")
}

el segundo parametro del EventListener es una referencia, por eso va sin parentesis

entonces, esto lo que hara, es que cuando nuestro usuario haga click en un boton, en la consola va a registrar esta interaccion, y en la consola aparecera "click". Esto signfica que le dimos vida a nuestra boton, y detecta los compartamientos del usuario

tambien podemos hacer lo mismo, pero usando una funcion flecha, 

ej) boton.addEventListener("click", () => console.log("Click"!))

esto es mucho mas funcional y estetico, ya que no sera algo que se repita constantemente, ya que es una accion sensilla por parte del usuario

let boton = document.getElementById("boton1")

boton.addEventListener("click", () => console.log("Click"!))

asi queda mucho mas simple

2) en la segunda opcion, vamos a usar una abreviacion, ya que usaremos metodos que terminen en on

la accion es la misma, pero cambia la sintaxis, queda en cada uno ver cual usar 

ej)

let boton = document.getElementById("boton1")

boton.onclick = () => console.log("Click")

y hay muchos mas metodos que terminan en on, que funcionan como eventhandlers (on.submit, on.check)

3) Esta opcion, para javascript no es lo mas recomendable pero en react se trabaja asi

por lo tanto, usaremos las dos primeras opciones.

Eventos mas comunes:

tenemos eventos que se pueden generar con el mouse, con el teclado, 
otros con un change, un input, un submit y otros

Eventos del mouse:

mousedown/mouseup
mouseover/mouseout
mousemove
click

Eventos del teclado:

keydown: cuando se presiona una tecla
keyup: cuando se suelta una tecla

Evento change: 

Este evento se activa cuando se detecta un cambio en un elemento, para esto se utilizan los input.onchange

otro tipo de input, es el input.value, que sirve para detectar cuando se hace un tipo de cambio sobre el input change

Evento submit:

este evento se activa cuando nosotros enviamos nuestro formulario, lo vamos a utilizar para darle una validacion en un formulario, en donde nosotros lo que pedimos tenga datos validos

esto sirve para darle vida a los botones em los cuales se envia la informacion

pero nosotros tenemos que obtener la informacion de estos inputs, ya que al dejarlo asi solamente se recarga la pagina y se borra la informacion de esos value

ej)

let formulario = document.getElementById("formulario")

formulario.addEventListener("submit", validateForm)

con esta funcion vamos a evitar que la pagina se recargue cuando se haga click

funcion validateForm(event){
    event.preventDefault()

    console.log("Enviado!")
}

Lo importante es lo que hace el preventDefault(), esto evita que la pagina se recargue, y lo que pusimos como e, o como event, es solamente una referencia, podria tener cualquier nombre

Informacion del evento:

en algunos casos, necesitamos obtener la informacion sobre el contexto sobre el cual se genera el evento, ya que el evento o el objeto se genera de forma automatica, entonces ese evento no solo lo vamos a utilizar para prevenir que se borre la informacion, si no que tambien lo podemos usar para otras utilidades

por ejemplo, en estos eventos se encuentra el item target, en donde se encuentran los formularios del evento

En este caso, esto nos va a devolver el formulario mediante un input, en forma de array, en donde se encuentra un monton de informacion


para obtener esto, lo tratamos como un metodo especial

let formulario = document.getElementById("formulario")

formulario.addEventListener("submit", validateForm)

function validateForm(event){
    event.preventDefault()

    let form = event.target 

    console.log(form[0].value)
    console.log(form[1].value)

    console.log("Enviado")
}

